<template>
  <div class="bank-simulation">
    <h1>–ò–º–∏—Ç–∞—Ü–∏—è –æ—á–µ—Ä–µ–¥–∏ –≤ –±–∞–Ω–∫–µ</h1>
    
    <div class="controls">
      <div class="slider-group">
        <label>–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–∫–æ–Ω: {{ counterCount }}</label>
        <input type="range" min="1" max="10" v-model.number="counterCount" :disabled="isRunning">
      </div>
      
      <div class="slider-group">
        <label>–°–∫–æ—Ä–æ—Å—Ç—å –æ–±—Ä–∞–±–æ—Ç–∫–∏: {{ processSpeed }} –º—Å</label>
        <input type="range" min="1000" max="10000" step="100" v-model.number="processSpeed" :disabled="isRunning">
      </div>
      
      <div class="slider-group">
        <label>–°–∫–æ—Ä–æ—Å—Ç—å –ø—Ä–∏—Ö–æ–¥–∞: {{ arrivalRate }} –º—Å</label>
        <input type="range" min="100" max="2000" step="50" v-model.number="arrivalRate" :disabled="isRunning">
      </div>
      
      <div class="slider-group">
        <label>–ú–∞–∫—Å. –∫–ª–∏–µ–Ω—Ç–æ–≤: {{ maxCustomers }}</label>
        <input type="range" min="5" max="50" v-model.number="maxCustomers" :disabled="isRunning">
      </div>
      
      <div class="button-group">
        <button @click="startSimulation" :disabled="isRunning">–°—Ç–∞—Ä—Ç</button>
        <button @click="stopSimulation" :disabled="!isRunning">–°—Ç–æ–ø</button>
        <button @click="resetSimulation">–°–±—Ä–æ—Å</button>
      </div>
    </div>
    
    <div class="stats">
      <div>–ö–ª–∏–µ–Ω—Ç–æ–≤ –≤ –±–∞–Ω–∫–µ: {{ bank.clients.length }}</div>
      <div>–°–≤–æ–±–æ–¥–Ω—ã—Ö –æ–∫–æ–Ω: {{ availableCounters }}</div>
      <div>–û–±—Å–ª—É–∂–µ–Ω–æ: {{ bank.totalServed }} / {{ maxCustomers }}</div>
      <div v-if="simulationFinished" class="simulation-finished">–°–∏–º—É–ª—è—Ü–∏—è –æ–∫–æ–Ω—á–µ–Ω–∞!</div>
    </div>
    
    <div class="bank-visualization" ref="bankArea">
      <div class="bank-walls">
        <div class="entrance-door"></div>
        
        <div 
          v-for="counter in bank.counters" 
          :key="counter.id"
          class="service-window"
          :style="{
            left: counter.position.x + 'px',
            top: counter.position.y + 'px',
            backgroundColor: counter.isAvailable ? '#4CAF50' : '#F44336'
          }"
        >
          <span v-if="counter.currentClient">‚è±Ô∏è</span>
          <span v-else>üëî</span>
        </div>
        
        <div 
          v-for="client in bank.clients" 
          :key="client.id"
          class="client"
          :class="{ 'client-leaving': client.isLeaving }"
          :style="{
            left: client.position.x + 'px',
            top: client.position.y + 'px'
          }"
        >
          <span class="client-emoji">üßç</span>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import { Bank, Counter, Client } from './models/Bank';

export default {
  data() {
    return {
      bank: new Bank(50),
      counterCount: 3,
      processSpeed: 3000,
      arrivalRate: 500,
      maxCustomers: 20,
      isRunning: false,
      simulationFinished: false,
      intervals: [],
      totalEntered: 0
    };
  },
  computed: {
    availableCounters() {
      return this.bank.counters.filter(c => c.isAvailable).length;
    }
  },
  watch: {
    counterCount(newVal) {
      this.initializeCounters(newVal);
    },
    processSpeed(newVal) {
      this.bank.counters.forEach(c => c.processTime = newVal);
    }
  },
  mounted() {
    this.initializeCounters();
    this.setupBankDimensions();
    window.addEventListener('resize', this.setupBankDimensions);
  },
  beforeUnmount() {
    this.stopSimulation();
    window.removeEventListener('resize', this.setupBankDimensions);
  },
  methods: {
    initializeCounters(count = this.counterCount) {
      this.bank.counters = Array.from({ length: count }, (_, i) => {
        return new Counter(i + 1, this.processSpeed);
      });
      this.positionCounters();
    },
    
    positionCounters() {
      if (!this.$refs.bankArea) return;
      
      const bankRect = this.$refs.bankArea.getBoundingClientRect();
      const offset = 70;
      
      this.bank.counters.forEach((counter, i) => {
        counter.position = {
          x: bankRect.width - offset,
          y: offset + i * (bankRect.height - 2 * offset) / this.counterCount
        };
      });
    },
    
    setupBankDimensions() {
      this.$nextTick(this.positionCounters);
    },
    
    startSimulation() {
      this.resetSimulation();
      this.isRunning = true;
      this.simulationFinished = false;
      
      // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–æ–≤—ã—Ö –∫–ª–∏–µ–Ω—Ç–æ–≤
      this.intervals.push(setInterval(() => {
        if (this.totalEntered >= this.maxCustomers * 2) return;
        if (this.bank.totalServed >= this.maxCustomers) return;
        
        const client = new Client();
        client.position = { 
          x: 50, 
          y: this.$refs.bankArea.clientHeight / 2 
        };
        client.targetPosition = this.getRandomPosition();
        
        this.bank.clients.push(client);
        this.totalEntered++;
      }, this.arrivalRate));
      
      // –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –∞–Ω–∏–º–∞—Ü–∏–∏ –∏ –ª–æ–≥–∏–∫–∏
      this.intervals.push(setInterval(() => {
        const now = Date.now();
        
        this.bank.clients.forEach(client => {
          // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —É—Ö–æ–¥ –±–µ–∑ –æ–±—Å–ª—É–∂–∏–≤–∞–Ω–∏—è
          if (!client.isWaiting && !client.targetCounter && 
              now - client.enteredTime > client.patience && 
              Math.random() < 0.005) {
            this.makeClientLeave(client);
            return;
          }
          
          // –û–±—Ä–∞–±–æ—Ç–∫–∞ —É—Ö–æ–¥—è—â–∏—Ö –∫–ª–∏–µ–Ω—Ç–æ–≤
          if (client.isLeaving) {
            this.handleLeavingClient(client);
            return;
          }
          
          // –ï—Å–ª–∏ –Ω–µ—Ç —Ü–µ–ª–∏ - –Ω–∞–∑–Ω–∞—á–∞–µ–º —Å–ª—É—á–∞–π–Ω—É—é
          if (!client.targetPosition) {
            client.targetPosition = this.getRandomPosition();
          }
          
          // –î–≤–∏–∂–µ–Ω–∏–µ –∫ —Ü–µ–ª–∏
          const dx = client.targetPosition.x - client.position.x;
          const dy = client.targetPosition.y - client.position.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance > 2) {
            client.position.x += (dx / distance) * client.speed;
            client.position.y += (dy / distance) * client.speed;
          } else {
            // –ï—Å–ª–∏ –¥–æ—Å—Ç–∏–≥–ª–∏ —Ü–µ–ª–∏
            if (client.targetCounter) {
              const counter = this.bank.counters.find(c => c.id === client.targetCounter);
              if (counter && counter.isAvailable) {
                this.serveClient(client, counter);
              } else {
                client.targetPosition = this.getRandomPosition();
                client.targetCounter = null;
                client.isWaiting = false;
              }
            } else {
              client.targetPosition = this.getRandomPosition();
              if (Math.random() < 0.05 && !client.isWaiting) {
                this.tryAssignToCounter(client);
              }
            }
          }
        });
        
        // –ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ –∫–ª–∏–µ–Ω—Ç–æ–≤ –∫ —Å–≤–æ–±–æ–¥–Ω—ã–º –æ–∫–Ω–∞–º (–ø–æ –æ–¥–Ω–æ–º—É –Ω–∞ –æ–∫–Ω–æ)
        if (this.availableCounters > 0) {
          const freeCounters = this.bank.counters.filter(c => c.isAvailable);
          freeCounters.forEach(counter => {
            const oldestClient = this.bank.clients
              .filter(c => !c.isWaiting && !c.targetCounter && !c.isLeaving)
              .sort((a, b) => a.id - b.id)[0];
            
            if (oldestClient) {
              oldestClient.targetCounter = counter.id;
              oldestClient.targetPosition = {
                x: counter.position.x - 30,
                y: counter.position.y
              };
              oldestClient.isWaiting = true;
            }
          });
        }
      }, 16));
    },
    
    tryAssignToCounter(client) {
      const freeCounter = this.bank.counters.find(c => c.isAvailable);
      if (freeCounter) {
        client.targetCounter = freeCounter.id;
        client.targetPosition = {
          x: freeCounter.position.x - 30,
          y: freeCounter.position.y
        };
        client.isWaiting = true;
      }
    },
    
    makeClientLeave(client) {
      client.isLeaving = true;
      client.targetPosition = {
        x: 30,
        y: this.$refs.bankArea.clientHeight / 2
      };
    },
    
    handleLeavingClient(client) {
      const dx = client.targetPosition.x - client.position.x;
      const dy = client.targetPosition.y - client.position.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance > 2) {
        client.position.x += (dx / distance) * client.speed * 1.5;
        client.position.y += (dy / distance) * client.speed * 1.5;
      } else {
        this.bank.clients = this.bank.clients.filter(c => c.id !== client.id);
        if (!client.served && this.bank.totalServed < this.maxCustomers) {
          this.addReplacementClient();
        }
      }
    },
    
    addReplacementClient() {
      if (this.totalEntered >= this.maxCustomers * 2) return;
      if (this.bank.totalServed >= this.maxCustomers) return;
      
      const client = new Client();
      client.position = { 
        x: 50, 
        y: this.$refs.bankArea.clientHeight / 2 
      };
      client.targetPosition = this.getRandomPosition();
      
      this.bank.clients.push(client);
      this.totalEntered++;
    },
    
    async serveClient(client, counter) {
      client.isWaiting = false;
      counter.isAvailable = false;
      counter.currentClient = client;
      
      await new Promise(resolve => setTimeout(resolve, counter.processTime));
      
      client.served = true;
      this.bank.totalServed++;
      
      client.isLeaving = true;
      client.targetPosition = {
        x: 30,
        y: this.$refs.bankArea.clientHeight / 2
      };
      
      await new Promise(resolve => {
        const checkExit = setInterval(() => {
          if (!client.targetPosition || Math.abs(client.position.x - 30) < 5) {
            clearInterval(checkExit);
            resolve();
          }
        }, 100);
      });
      
      this.bank.clients = this.bank.clients.filter(c => c.id !== client.id);
      counter.isAvailable = true;
      counter.currentClient = null;
      
      if (this.bank.totalServed >= this.maxCustomers) {
        this.finishSimulation();
      } else {
        this.addReplacementClient();
      }
    },
    
    stopSimulation() {
      this.intervals.forEach(clearInterval);
      this.intervals = [];
      this.isRunning = false;
    },
    
    finishSimulation() {
      this.stopSimulation();
      this.simulationFinished = true;
    },
    
    resetSimulation() {
      this.stopSimulation();
      this.bank = new Bank(50);
      this.bank.totalServed = 0;
      this.totalEntered = 0;
      this.simulationFinished = false;
      this.initializeCounters();
    },
    
    getRandomPosition() {
      return {
        x: 100 + Math.random() * (this.$refs.bankArea.clientWidth - 200),
        y: 50 + Math.random() * (this.$refs.bankArea.clientHeight - 100)
      };
    }
  }
};
</script>

<style scoped>
.bank-simulation {
  font-family: Arial, sans-serif;
  max-width: 900px;
  margin: 0 auto;
  padding: 20px;
}

.controls {
  margin: 20px 0;
  padding: 15px;
  background: #f5f5f5;
  border-radius: 8px;
}

.slider-group {
  margin-bottom: 15px;
}

.slider-group label {
  display: block;
  margin-bottom: 5px;
}

.slider-group input {
  width: 100%;
}

.button-group {
  display: flex;
  gap: 10px;
  margin-top: 15px;
}

button {
  padding: 8px 16px;
  background: #4CAF50;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

button:disabled {
  background: #cccccc;
}

.stats {
  display: flex;
  flex-wrap: wrap;
  gap: 15px;
  margin: 20px 0;
  padding: 10px;
  background: #e8f5e9;
  border-radius: 8px;
}

.simulation-finished {
  color: #f44336;
  font-weight: bold;
}

.bank-visualization {
  position: relative;
  width: 100%;
  height: 500px;
  background-color: #f5f5f5;
  border: 4px solid #333;
  border-radius: 8px;
  overflow: hidden;
  box-shadow: 0 0 15px rgba(0,0,0,0.2);
}

.bank-walls {
  position: relative;
  width: 100%;
  height: 100%;
  background-color: #f9f9f9;
}

.entrance-door {
  position: absolute;
  width: 40px;
  height: 80px;
  left: 10px;
  top: 50%;
  transform: translateY(-50%);
  background-color: #8D6E63;
  border: 2px solid #5D4037;
}

.service-window {
  position: absolute;
  width: 50px;
  height: 80px;
  background-color: #4CAF50;
  border: 2px solid #2E7D32;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 24px;
  z-index: 2;
}

.client {
  position: absolute;
  width: 30px;
  height: 30px;
  transform: translate(-50%, -50%);
  transition: left 0.3s ease-out, top 0.3s ease-out;
  display: flex;
  flex-direction: column;
  align-items: center;
  z-index: 1;
}

.client-emoji {
  font-size: 24px;
  margin-bottom: 2px;
  filter: drop-shadow(0 0 2px rgba(0,0,0,0.3));
}

.client-leaving {
  opacity: 0.7;
  transform: translate(-50%, -50%) scale(0.9);
  transition: all 0.5s ease-out;
}
</style>